Homework 1 - P8105
================
Sergio Ozoria Ramírez (smo2147)
2025-09-18

# Initial Setup

Loading the tidyverse package for scatterplot + moderndive package to
access the penguins dataset.

``` r
library(tidyverse)
library(moderndive)
```

# Problem 1

#### Description of Dataset

We will now access the weather dataset and provide a short description
of the data using inline R code.

``` r
data("early_january_weather")
```

The weather dataset has **358 rows** and **15 columns**. One important
variable that stands out in this dataset is the **temperature** variable
(i.e., `temp`), along with hour (i.e., `hour`) and the wind speed (i.e.,
`wind_speed`), which are critical in regulating/influencing temperature
levels. It is important to note that the average temperature has a mean
of **39.5821229** in Fahrenheit. Moreover, the average hour is
**11.5307263** and the average wind speed is **8.2258269** in the month
of January, 2013.

The following table describes the remaining variables that were also
used to capture observations in weather patterns in the month of
January, year 2013:

| Variable | Description |
|----|----|
| `origin` | Weather stations |
| `year` | Year of observation |
| `month` | Month of observation |
| `hour` | Hour of the day |
| `day` | Day of observation |
| `dewp` | Dew point temperature in Fahrenheit |
| `humid` | Relative humidity at time of observation |
| `wind_dir` | Wind direction in degrees at time of observation |
| `wind_gust` | Peak instantaneous wind speed in miles per hour at observation. |
| `precip` | Precipitation in inches at the time of observation |
| `pressure` | Sea level pressure in millibars at time of observation |
| `visib` | Visibility in miles at time of observation |
| `time_hour` | Date and hour at the time of observation |

#### Dataframe for Scatter Plot

Before we plot what the temperature by the hour looks like in a scatters
plot, let’s use the selection function to create a dataframe for the
variables `time_hour`, `temp`, and `humid`.

``` r
weather_df =
  early_january_weather |>
  select(time_hour, temp, humid
  )
```

#### Plotting Scatter Plot

We will now plot the variables `temp` and `time_hour` to see how the
temperature changed by the hour.

``` r
ggplot(
  weather_df, aes
       (x = time_hour, 
        y = temp, 
        color = humid)) + 
  geom_point() + 
  labs(
    x = "Date and Hour", 
    y = "Temperature (°F)", 
    color = "Humidity",
    title = "Temperature vs Time of Day, Early January 2013") +
  theme_minimal() +
  theme(plot.title = 
          element_text 
        (hjust = 0.5)
        )
```

![](p8105_hw1_smo2147_files/figure-gfm/plotting%20weather%20patterns-1.png)<!-- -->

This scatterplot depicts temperature patterns over time, as well as
changes in humidity levels throughout the month of January in 2013. As
the temperature rises by the hour over the course of the month, humidity
levels also tend to increase. It is important to note that humidity
levels are generally lower in the mornings and higher in the afternoons,
reflecting daily fluctuations in the temperature. This could be caused
by rises in the sun’s temperature and cooling of the Earth’s surface.

#### Exporting Scatterplot

Let’s now save the scatterplot depicting temperature patterns by time
and hour to my project directory.

``` r
ggsave("temp_thour_sctplot.pdf", height = 4, width = 6)
```

# Problem 2

#### Dataframe for Random Sample & Vectors

Let’s create a dataframe that consists of a random sample size of with a
standard normal distribution. This will also include the following:

- A logical vector indicating whether elements in that sample are
  greater than 0
- A character vector of length 10
- A factor vector length 10 depicting 3 different factor levels

``` r
set.seed(123)

rsamp_df = tibble(
  norm_rsamp = rnorm(10, mean = 0, sd = 1),
  gt_zero = norm_rsamp > 0,
  char_vec = as.character(1:10),
  factor_vec = factor(
    c("chicken", "rice", "beans", "chicken",
      "rice", "beans", "chicken", "rice",
      "beans", "chicken"),
  levels = c("chicken", "rice", "beans")
  )
)
```

##### Means of Each Vector in `rsamp_df`

We will now take the mean for each variable listed in the random sample
dataframe (i.e., `rsamp_df`) listed above.\`

``` r
rsamp_df |> 
  pull(norm_rsamp) |> 
  mean()
## [1] 0.07462564

rsamp_df |> 
  pull(gt_zero) |> 
  mean()
## [1] 0.5

rsamp_df |> 
  pull(char_vec) |> 
  mean()
## Warning in mean.default(pull(rsamp_df, char_vec)): argument is not numeric or
## logical: returning NA
## [1] NA

rsamp_df |> 
  pull(factor_vec) |> 
  mean()
## Warning in mean.default(pull(rsamp_df, factor_vec)): argument is not numeric or
## logical: returning NA
## [1] NA
```

Based on these results, we are able to get the mean for the variables
`norm_rsamp` and `gt_zero`. This is because `norm_rsamp` is averaging
each random, numeric observation from the sample, whereas R is coercing
**TRUE** and **FALSE** values in `gt_zero` as 1 and 0, respectively,
which allows us to make operations such as the mean.

However, we are unable to calculate the mean for the variables
`char_vec` and `factor_vec` because it requires numeric or logic input.
This is because `char_vec` is treating the data as text. Even if its
observations were numbers, R will treat all contents in the character
vector as texts. In the case `factor_vec`, it is encoding a vector as
categorical data, thus lacking numerical value to get the mean or
statistical validity from numbers that are assigned to categories.
Therefore, when we evaluate these variables, the output will return with
an **NA** warning because the `mean()` function is only defined by for
numeric or logical variables.

#### Coercion of Different Data Types

We will now attempt to convert all vector variables in my dataframe,
`rsamp_df`, to numeric values using the `as.numeric` function without
evaluating its output.

``` r
rsamp_df |> 
  mutate(
    gt_zero_an = gt_zero |> 
      as.numeric(),
    char_vec_an = char_vec |> 
      as.numeric(),
    factor_vec_an = factor_vec |> 
      as.numeric()
  )
```

After coercing logical, character, and factor variables to numeric
values, we can see that the function `as.numeric` converts the values
**TRUE** and **FALSE** as binary outcomes of 1 and 0, respectively for
the variable `gt_zero`. Calculating the mean for this logical variable
using values of 1 and 0, or **TRUE** and **FALSE**, provides a mean of
**0.5** representing the proportion of **TRUE** values greater than 0.
This is only dependent on how many values are either false or true.

In the case of the variable `char_vec`, we can see that the digit
characters changed to numeric values at the time of coercion, which
allows us to calculate the mean, averaging to **5.5**. However, if the
character value contained text instead of digit characters, the output
would produce an **NA** warning at the time of coercion because text
characters cannot be converted to numbers.

In the case of the variable `factor_vec`, we can see that each category
is assigned a numerical integer based on level order of the factor
(i.e., 1 for chicken, 2 for rice, and 3 for beans). This allows us to
calculate a mean averaging to **1.9**. However, this mean wouldn’t be
meaningful because we’re assigning order to categorical data.
